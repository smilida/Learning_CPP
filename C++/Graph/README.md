# 图（Graph）
关于图的数据结构

## 邻接表
邻接表是一种表示图的数据结构，它使用链表来表示图中每个节点的邻接点。对于每个节点，邻接表中存储了以该节点为起点的所有边。邻接表可以用于表示无向图和有向图，以及带权图。

具体来说，对于无向图中的每个节点，邻接表中存储了该节点的所有邻接点；对于有向图中的每个节点，邻接表中存储了以该节点为起点的所有出边。如果图是带权图，则邻接表中存储的是每条边的权重。

邻接表的优点在于它可以很方便地找到每个节点的邻接点，并且可以很容易地遍历图中的所有边。邻接表的缺点在于，如果需要查找某个节点的入度，需要遍历整个图，效率较低。

在实现中，邻接表可以使用数组、链表、向量等数据结构来实现。对于稠密图，可以使用数组来存储邻接表；对于稀疏图，可以使用链表或向量来存储邻接表。

## 有向无环图（Directed Acyclic Graph）
有向无环图（Directed Acyclic Graph，DAG）是一种由有向边连接节点的图形结构，其中不会存在任何形成环路的有向路径。这意味着从一个节点出发，无论沿着有向边向哪个方向遍历，最终都不会回到该节点。

在DAG中，每个节点代表一个实体，每条有向边则表示一种从一个实体到另一个实体的关系。DAG通常用于建立事件发生的先后顺序、任务调度、数据流向等情景中，比如在编译器中，DAG可以用于优化代码生成过程；在生物信息学中，DAG可用于描述基因调控网络等。

DAG具有许多有用的特性，比如可以进行拓扑排序，用于确定图中节点的依赖关系；并且可以避免出现循环依赖，避免了在处理依赖关系时出现死循环的情况。

### 1. DAG.cc
该代码中，DAG类表示有向无环图，包含了节点数V和邻接表adjList。addEdge函数用于添加有向边，printGraph函数用于打印邻接表。在main函数中，我们创建了一个包含5个节点的有向无环图，并添加了若干条有向边，最后打印邻接表。

### 2. DAG_LongestPath.cc
该代码中，我们使用邻接表来表示有向无环图，其中`adjList`是一个二维向量，每个元素是一个pair类型，表示一条有向边和其权重。在构造函数中，我们需要传入节点数，然后调用`resize`函数来初始化邻接表的大小。

`addEdge`函数用于向邻接表中添加有向边。对于节点u到节点v的有向边，我们可以使用pair类型来表示这条边和其权重，然后将其插入到节点u对应的邻接表中。

`topologicalSort`函数用于计算有向无环图的拓扑排序序列。首先，我们需要记录每个节点的入度，然后遍历所有的节点和它们的邻接表，统计每个节点的入度。接着，我们将入度为0的节点加入到队列中，并从队列中不断取出入度为0的节点，将它们加入到拓扑排序序列中，并将它们的邻接点的入度减1。重复执行该操作，直到队列为空。

`longestPath`函数用于求解有向无环图的最长路径。首先，我们需要获取拓扑排序序列，并初始化一个大小为节点数的dist向量，用于记录每个节点到起点的最长路径长度。然后，我们将起点的最长路径长度设置为0，并依次遍历拓扑排序序列中的每个节点。对于每个节点，我们遍历其所有邻接点，更新邻接点的最长路径长度。具体来说，对于节点u到节点v的有向边，我们可以使用`dist[v] = max(dist[v], dist[u] + w)`来更新节点v的最长路径长度，其中w表示边(u, v)的权重。最后，我们返回终点的最长路径长度即可。

以上算法的时间复杂度为O(V+E)，其中V和E分别表示节点数和边数。空间复杂度为O(V)，其中V表示节点数。
